<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>读书笔记--进程管理</title>
    <link href="/2022/10/01/process/"/>
    <url>/2022/10/01/process/</url>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h2><h3 id="Linux中的进程表示"><a href="#Linux中的进程表示" class="headerlink" title="Linux中的进程表示"></a>Linux中的进程表示</h3><p>Linux中的进程采用C语言结构task_struct来表示，它位于内核源码&lt;Linux&#x2F;sched.h&gt;,这个结构包含进程状态、调度和内存管理信息、打开文件列表、指向父进程、子进程和兄弟进程列表的指针</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><strong>调度队列</strong></p><ul><li>进程在进入系统时，会被加到<strong>作业队列(jobqueue)</strong>,这个队列包括系统内的所有进程</li><li>驻留在内存中的、就绪的、等待运行的进程保存在**就绪队列(readyqueue)**上。</li><li>等待特定I&#x2F;O设备的进程列表.称为**设备队列(devicequeue)**。每个设备都有自己的设备队列</li></ul><img src="/2022/10/01/process/1.png" class=""><p>上下文切换：保存当前进程执行状态并且恢复另一个进程的执行状态</p><h3 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h3><p><strong>Linux中进程的创建</strong></p><p>当进程创建新进程时，可有两种执行可能：</p><ul><li>父进程与子进程并发执行。</li><li>父进程等待，直到某个或全部子进程执行完（wait系统调用）</li></ul><p>新进程的地址空间也有两种可能：</p><ul><li>子进程是父进程的复制品(它具有与父进程同样的程序和数据)</li><li>子进程加载另一个新程序（后面提到的exec系统调用）</li></ul><img src="/2022/10/01/process/2.png" class=""><ul><li>系统调用fork返回子进程的pid&#x3D;0，父进程的pid非零</li><li>通常，在系统调用fork()之后，有个进程使用系统调用exec(),以用新程序来取代进程的内存空间。系统调用exec()加载二进制文件到内存中(破坏了包含系统调用exec()的原来程序的内存内容)，并开始执行，因为调用exec()用新程序覆盖了进程的地址空间，所以调用execO除非出现错误，不会返回控制</li><li>wait系统调用，父进程等待子进程执行</li></ul><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ul><li>进程自身调用exit系统调用来请求终止，并且释放资源，可以返回状态值到父进程(到wait)</li></ul><p><strong>僵尸进程和孤儿进程</strong></p><ul><li>当进程终止后，操作系统会释放其资源，但是它在进程表中的条目还是存在的，直到它的父进程调用wait()，当进程已经终止，但是其父进程尚未调用wait(),这样的进程称为<strong>僵尸进程(zombieprocess)</strong></li><li>如果父进程没有调用wait就终止，以致于子进程成为**孤儿进程(orphanprocess)**，Linux会将init作为孤儿进程的父进程，而init进程会定期调用wait()，以便收集任何孤儿进程的退出状态。</li></ul><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信的两种基本模型</p><ul><li>共享内存</li><li>消息传递</li></ul><p><strong>共享内存</strong></p><ul><li><strong>POSIX共享内存</strong><ol><li>进程通过系统调用shm_open()创建共享内存对象<ul><li>POSIX共享内存的实现为内存映射文件，它将共享内存区域与文件相关联</li><li><code>shm_fd=shm_open(name,O_CREAT|0_RDRW,0666)</code><ul><li>第一个参数为共享内存对象的名称，即文件名(char*类型)</li><li>第二个参数是宏定义代表：当文件不存在时，需要创建共享内存(O_CREAT)对象，需要打开以便读写(O_RDRW)</li><li>第三个参数是文件的权限0666(rw-rw-rw-)</li></ul></li></ul></li><li>调用<code>ftruncate()</code>用于配置对象的大小(以字节为单位)<ul><li>比如 <code>ftruncate(shm_fd,4096);</code></li></ul></li><li>调用mmap创建内存映射文件来包含共享内存对象</li></ol></li></ul><p>生产者进程—创建共享内存对象并写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/*the size(in bytes) of shared memory object*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SIZE=<span class="number">4096</span>;</span><br><span class="line"><span class="comment">/*name of the shared memory object*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name=<span class="string">&quot;DS&quot;</span>;</span><br><span class="line">/strings written to shared memory*/</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *message_0=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *message_l=<span class="string">&quot;World!&quot;</span>;</span><br><span class="line"><span class="comment">/*shared memory file descriptor*/</span></span><br><span class="line"><span class="type">int</span> shm_fd;</span><br><span class="line"><span class="comment">/*pointertosharedmemoryobect*/</span></span><br><span class="line"><span class="type">void</span>*ptr;</span><br><span class="line"><span class="comment">/*create the shared memory object*/</span></span><br><span class="line">shm_fd=shm_open(name,<span class="number">0</span>-CHEATI0_RDRW,<span class="number">0666</span>);</span><br><span class="line"><span class="comment">/*configure the size of the shared memory object*/</span></span><br><span class="line">ftruncate(shm_fd,SIZE);</span><br><span class="line"><span class="comment">/*memory map the shared memory object*/</span></span><br><span class="line">ptr=mmap(<span class="number">0</span>,SIZE,PROT_WRITE,MAP-SHARED,shm_fd,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*write to the shared memory object*/</span></span><br><span class="line"><span class="built_in">sprintf</span>(ptr,<span class="string">&quot;%s&quot;</span>,message_0);</span><br><span class="line">ptr+=<span class="built_in">strlen</span>(message_0);</span><br><span class="line"><span class="built_in">sprintf</span>(ptr,<span class="string">&quot;%sM,message_1);</span></span><br><span class="line"><span class="string">ptr+=strlen(message_l);</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>消费者进程—读消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/*the size (inbytes) of shared memory object*/</span></span><br><span class="line">constintSIZE=<span class="number">4096</span>;</span><br><span class="line"><span class="comment">/*name of the shared memory object*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name=<span class="string">&quot;OS&quot;</span>;</span><br><span class="line"><span class="comment">/*shared memory file descriptor*/</span></span><br><span class="line"><span class="type">int</span> shm_fd;</span><br><span class="line"><span class="comment">/*pointer to shared memory obect*/</span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"><span class="comment">/*open the shared memory object*/</span></span><br><span class="line">shm_fd=shm_open(name,<span class="number">0</span>_RD0NLY,<span class="number">0666</span>);</span><br><span class="line"><span class="comment">/*memory map the shared memory object*/</span></span><br><span class="line">ptr=mmap(<span class="number">0</span>,SIZE,PROT-READ,MAP-SHARED,shm_fd,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*read from the shared memory object*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="type">char</span>*)ptr);</span><br><span class="line"><span class="comment">/*remove the shared memory object*/</span></span><br><span class="line">shm_unlink(name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消息传递</strong></p><ol><li>直接通信<ul><li>需要在每两个进程之间建立逻辑通信链路</li><li>每个通信的进程需要指定消息的发送者和接收者，<strong>对称通信</strong>原语send和receive<ul><li>Q进程：send(P,message)</li><li>P进程：receive(Q,message)</li></ul></li></ul></li><li>间接通信<ul><li>通过邮箱或端口来发送和接受消息，邮箱可以抽象为一个对象</li><li>一个进程可以通过多个不同邮箱与另一个进程通信，但是两个进程只有拥有一个共享邮箱时才能通信</li><li>send和receive原语定义<ul><li>send（A，message）向邮箱A发送消息</li><li>receive(A,message):从邮箱A接收message</li></ul></li></ul></li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>线程是使用CPU的基本单元，包括线程ID，程序计数器、寄存器组和堆栈，它与同一进程的其他线程共享代码段、数据段和其他操作系统资源(如打开的文件对象)</p><img src="/2022/10/01/process/3.png" class=""><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>进程其实就是内存中的一段区域，这段区域保存了CPU执行的机器指令以及函数的堆栈信息，想要让进程执行，就是将main函数的第一条机器指令写入PC寄存器</p><ul><li><p>进程只有一个入口函数，只有一个执行流</p></li><li><p>把PC寄存器指向该段内存空间中的其他入口函数，就产生了线程，一个进程内可以有多个入口函数，也就是说属于同一个进程中的机器指令可以被多个CPU同时执行。</p>  <img src="/2022/10/01/process/4.png" class=""></li><li><p>每个线程有自己独立的栈空间</p></li></ul><h3 id="用户线程和内核线程"><a href="#用户线程和内核线程" class="headerlink" title="用户线程和内核线程"></a>用户线程和内核线程</h3><p><strong>关于系统中线程有三种模型：</strong></p><ol><li><p>用户级线程：内核不知道。 用户自己创建&#x2F;实现&#x2F;销毁线程。</p><ul><li>用户线程是指完全在用户空间创建的多个task，内核并不知道(对内核是透明的，内核还是当作一个进程来调用)， 用户自己创建&#x2F;实现&#x2F;销毁线程(<strong>用户程序实现调度</strong>)。并不能实现真正意义上的并行</li><li>操作系统不能调度用户级别线程，只能等待用户线程主动放弃CPU（<strong>用户程序实现调度</strong>）</li><li>进程中包含线程，用户线程在用户空间中实现，内核并没有直接对用户线程进程调度，<strong>内核的调度对象和传统进程一样，还是进程本身，内核并不知道用户线程的存在。</strong></li><li>处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。</li></ul> <img src="/2022/10/01/process/5.png" class=""></li><li><p>内核级线程：内核直接支持一个进程中的多个控制线程。</p><ul><li>内核线程就是内核的分身，一个分身可以处理一件特定事情。</li></ul></li><li><p>轻量级进程(LWP)：由内核调度，但可以与用户线程绑定。</p><ul><li>在内核之上并由内核支持的用户线l程，由clone()系统调用创建</li><li>大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在user mode和kernel mode中切换。</li><li>处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源</li><li>P,LWP在用户空间，K是内核线程</li></ul> <img src="/2022/10/01/process/6.png" class=""></li></ol><p><a href="https://www.zhihu.com/question/35128513">Linux下调用pthread库创建的线程是属于用户级线程还是内核级线程？求大神指教?</a></p><p><a href="https://juejin.cn/post/6844903962504593421">用户级线程和内核级线程，你分得清吗？</a></p><p><a href="https://blog.csdn.net/gatieme/article/details/51481863">内核线程、轻量级进程、用户线程三种线程概念解惑（线程≠轻量级进程）_OSKernelLAB-CSDN博客_轻量级进程</a></p><p><strong>内核进程和用户进程的三种映射方式</strong></p><ul><li>多对一模型<ul><li>映射多个用户级线程到一个内核线程，线程管理是由用户空间的线程库来完成的，因此效率更高，对应着上述的用户级别线程的实现</li><li>如果一个线程执行阻塞系统调用，那么整个进程将会阻塞。</li><li>任一时间只有一个线程可以访问内核.所以多个线程不能并行运行在多处理核系统上。</li></ul></li><li>—对一模型<ul><li>Linux的pthreads线程库就是使用的这种模型，映射每个用户线程到一个内核线程</li><li>该模型在一个线程执行阻塞系统调用时，能够允许另一个线程继续执行</li><li>唯一缺点是，创建一个用户线程就要创建一个相应的内核线程。由于创建内核线程的开销会影响应用程序的性能</li></ul></li><li>多对多模型<ul><li>多路复用多个用户级线程到同样数量或更少数量的内核线程</li></ul></li></ul><h3 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a><strong>线程库</strong></h3><p>两种线程库：</p><ol><li>在用户空间中提供一个<strong>没有内核支持的库</strong>。这种库的所有代码和数据结构都位于<strong>用户空间</strong>。</li><li>实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。eg.POSIX的pthreads库。</li></ol><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>如果允许所有并发请求都通过新线程来处理，那么我们没有限制系统内的并发执行线程的数量。线程池可以解决这个问题。</li><li><strong>在进程开始时创建一定数量的线程，并加到池中以等待工作</strong>。当服务器收到请求时，它会唤醒池内的一个线程(如果有可用线程)，并将需要服务的请求传递给它。一旦线程完成了服务，它会返回到池中再等待工作。如果池内没有可用线程，那么’7服务器会等待，直到有空线程为止。</li></ul><h2 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>需要进行CPU调度的情况分为以下四种：</strong></p><ol><li>当一个进程运行状态切换到等待状态(IO请求，wait()调用以便等待子进程的终止)</li><li>一个进程从运行状态切换到就绪状态(中断)</li><li>一个进程从等待切换到就绪状态(IO完成)</li><li>进程终止</li></ol><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>CPU调度处理的问题是：从就绪队列中选择进程为其分配CPU</p><ol><li><p>先到先服务(FCFS)</p><ul><li>通过FIFO队列实现，当一个进程进入就绪队列时，他的PCB会被链接到队列尾部。当CPU空闲时，他会分配给队列头部的进程，并且将进程从队列中移去。</li></ul></li><li><p>最短作业优先调度(SJF)</p><ul><li>剩余占用CPU时间越少，则优先调度</li></ul><p> 分为抢占式和非抢占式</p><ul><li>非抢占式即进程获得CPU之后不会被抢占</li><li>抢占式即进程获得CPU后，如果后续又有某个进程的剩余CPU更短，则抢占CPU</li></ul></li><li><p>优先级调度</p></li><li><p>轮转调度(RR)</p><p> 专门为分时系统设计的</p></li><li><p>多级队列调度</p><ul><li>将进程分为不同的组，如前台进程和后台进程，前台进程往往有更高的优先级</li><li>多级队列算法就绪队列分为多个单独的队列</li></ul></li><li><p>多级反馈队列</p><p> 允许进程在不同的就绪队列中进行切换</p></li></ol><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>竞争范围</strong></p><ol><li><p>进程竞争范围(PCS)</p><p> 同一个进程的线程之间竞争CPU（用户级别线程）</p><p> 当某个用户级线程获得CPU，比如调度到<strong>可用LWP</strong>之后，之后陷入内核态，等待操作系统调度内核线程</p></li><li><p>系统竞争范围(SCS)</p><p> 和系统内所有的内核级线程抢占CPU，采用一对一模型的系统，只采用SCS</p></li></ol><p><strong>Pthread调度</strong></p><ol><li>PTHREAD_SCOPE_PROCESS:按PCS来调度线程<ul><li>将用户级别线程调度到可用LWP，LWP由线程库维护</li></ul></li><li>PTHREAD_SCOPE_SYSTEM:按SCS来调度线程<ul><li>创建一个LWP，将每个用户级别线程绑定到LWP，采用一对一策略来映射线程</li></ul></li></ol><p><strong>Pthread API</strong></p><p>获取和设置竞争策略</p><p>pthread_attr_setscope(pthread_attr_t<em>attr,intscope)</em></p><p><em>pthread_attr_getscope(pthread_attr_t</em>attr,int*scope)</p><h3 id="多核处理器调度"><a href="#多核处理器调度" class="headerlink" title="多核处理器调度"></a>多核处理器调度</h3><h3 id="实时CPU调度"><a href="#实时CPU调度" class="headerlink" title="实时CPU调度"></a>实时CPU调度</h3><p><strong>基本概念</strong></p><ol><li>软实时系统</li><li>硬实时系统</li></ol><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="Peterson解决方案"><a href="#Peterson解决方案" class="headerlink" title="Peterson解决方案"></a>Peterson解决方案</h3><p>以两个进程Pi，Pj为例，两个进程共享两个数据项</p><p><code>int turn;</code>turn&#x3D;i表示Pi能够进入临界区 </p><p><code>boolean flag[2];</code>flag[i]&#x3D;true,表示Pi正在争抢进入临界区，<strong>退出临界区将自己的flag置为flase</strong></p><ul><li>Pi进程的代码  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">flag[i]=<span class="literal">true</span>;</span><br><span class="line">turn=j;</span><br><span class="line"><span class="keyword">while</span>( flag[j] &amp;&amp; turn==j );</span><br><span class="line"><span class="comment">//临界区代码</span></span><br><span class="line">flag[i]=flase;<span class="comment">//退出临界区，置为flase</span></span><br><span class="line"><span class="comment">//剩余区代码</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>  对于上述代码(进程Pi)，两种情况可以跳出while循环进入临界区<ul><li>Pj已经退出临界区，将flag[j]置为了flase</li><li>turn&#x3D;&#x3D;i，两个进程都在抢占进入临界区，但是Pi抢到进入权</li></ul></li></ul><h3 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h3><p>解决临界区问题都是基于<strong>加锁</strong>为前提的</p><p>通过<strong>中断</strong>解决临界区问题</p><ul><li>对于单处理器环境，可以在修改共享变量时禁止中断出现，就可以保证当前指令流有序执行，不会被抢占</li><li>但是对于多处理器环境，中断禁止会很耗时，因为消息要传递到所有的处理器</li></ul><p>现代处理器提供了<strong>原子指令</strong></p><ul><li><code>test_and_set()</code></li><li><code>compare_and_swap()</code></li></ul><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>一个进程在进入临界区时应得到锁；它在退出临界区时释放锁。函数acquire()获取锁，而函数release()释放锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line"><span class="keyword">while</span>(!available);<span class="comment">/*busy wait*/</span></span><br><span class="line">available=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">available=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：<strong>忙等待：</strong>如果一个进程在临界区中，任何其他进程想要进入必须连续循环调用acquire()，这种类型的锁也叫自旋锁</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>一个信号量(semaphore)S<strong>包括一个整数和一个PCB链表指针</strong>，除了初始化之外只能通过两个原子操作访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span><span class="comment">//PCB链表指针</span></span><br><span class="line">&#125;semaphore;<span class="comment">//信号量定义</span></span><br></pre></td></tr></table></figure><ol><li><p>wait(&amp;S)</p><p> 进程调用wait之后，value值减一，如果value小于0，则<strong>将进程添加到等待队列，并将自己阻塞</strong>(这一点与加锁的忙等待不同)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore* S)&#123;</span><br><span class="line">S-&gt;value―;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">add this process to S-&gt;<span class="built_in">list</span>;</span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(&amp;S)</p><p> 等待信号量S而阻塞的进程，在其他进程执行signal()后，被wakeup()，从而从等待队列进入就绪队列</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">S-&gt;value++;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">remove a process P from S-&gt;<span class="built_in">list</span>;</span><br><span class="line">wakeup(P);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>对同一信号量，没有两个进程可以同时执行操作wait()和signal()</p><ul><li><p>对于单处理器环境，在执行操作waitO和signal()时，可以简单禁止中断来</p></li><li><p>对于多处理器环境，每个处理器的中断都应该被禁止，但是会严重影响性能</p><p>  使用加锁技术实现，如自旋锁，所以<strong>使用信号量并没有完全取消忙等待</strong>，<strong>只是将临界区从原来的可能很长的代码段转化为了对wait和signal代码段的忙等待</strong>，这些区比较短，临界区几乎不会被占用，忙等待时间很短。</p></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>基本概念</strong></p><p>具有等待队列的信号量实现可能导致这样的情况：两个或多个进程无限等待一个事件,而该事件只能由这些等待进程之一来产生。这里的事件是执行操作signal。。当出现这样的状态时，这些进程就为死锁(deadlocked)</p><p><strong>举例</strong></p><p>两个进程P0和P1共享信号量S和Q，两个信号量初始值为1</p><img src="/2022/10/01/process/7.png" class=""><p>当P0执行了wait(S)，P1执行了wait(Q)，此时S和Q的value均为0，之后P0再执行wait(Q)，P1再执行wait(S)，二者都在等待对方发送signal</p><h3 id="有界缓冲区-生产者-消费者问题"><a href="#有界缓冲区-生产者-消费者问题" class="headerlink" title="有界缓冲区(生产者-消费者问题)"></a>有界缓冲区(<strong>生产者-消费者问题</strong>)</h3><p><strong>初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">semaphore empty=n;</span><br><span class="line">semaphore full=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>生产者进程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line"><span class="comment">/*produce an item in next_produced*/</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">wait(empty);</span><br><span class="line">wait(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*add next_produced to the buffer*/</span></span><br><span class="line"></span><br><span class="line">signal(mutex);</span><br><span class="line">signal(full);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><strong>消费者进程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">wait(full);</span><br><span class="line">wait(mutex);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">/*remove an item from buffer to next_consumed*/</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">signal(mutex);</span><br><span class="line">signal(empty);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*consume the item in next_consumed*/</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>一个哲学家需要同时拿起左右两根筷子才能进食</p><img src="/2022/10/01/process/8.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>];<span class="comment">//所有元素初始化为1</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">wait(chopstick[i]);</span><br><span class="line">wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//eat 临界区</span></span><br><span class="line"></span><br><span class="line">signal(chopstick[i]);</span><br><span class="line">signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>但是如果所有的哲学家同时拿起左边的筷子，则会产生死锁</p><p><strong>解决方案：</strong></p><img src="/2022/10/01/process/9.png" class=""><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>未完待续……</p><h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记--内存管理</title>
    <link href="/2022/10/01/mem/"/>
    <url>/2022/10/01/mem/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><h3 id="内存交换和内存覆盖"><a href="#内存交换和内存覆盖" class="headerlink" title="内存交换和内存覆盖"></a>内存交换和内存覆盖</h3><p><a href="https://blog.csdn.net/dongyanxia1000/article/details/51425141">内存覆盖和内存交换_dongyanxia1000的专栏-CSDN博客_内存覆盖技术</a></p><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>属于早期内存分配方法。</li><li>内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。</li></ul><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><ul><li>重定位寄存器(基址寄存器)和界限寄存器，或者上下界寄存器</li><li>MMU通过将逻辑地址加上重定位寄存器的值进行映射</li></ul><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><strong>固定分区</strong></p><p>将内存分为多个固定大小的分区(partition)o每个分区可以只包含一个进程。</p><p><strong>可变分区</strong></p><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h3><p><strong>维护三种表</strong></p><ol><li><p>页表</p><p> 每个进程维护一个页表，页表的长度和首地址存放在该进程的PCB中</p></li><li><p>请求表</p><p> 操作系统维护<strong>一张</strong>请求表，记录了每个进程页表的起始地址和长度</p></li><li><p>存储页面表</p><p> 整个系统一张表，记录了内存中各页面是否被分配，有两种表示方式</p><ul><li>位图法，用一块固定区域，每位0&#x2F;1表示某页是否被分配</li><li>空闲页面链，用链表记录，空闲区的第一个和第二个页存储当前空闲区的页面数和下一个空闲区的首地址</li></ul></li></ol><h3 id="内存分配-1"><a href="#内存分配-1" class="headerlink" title="内存分配"></a>内存分配</h3><p>页表在内存中占有一块固定的存储区</p><p><strong>静态页式管理</strong></p><ul><li>操作系统将进程的所有页表项全部存储到内存中</li></ul><p><strong>动态页式管理</strong></p><ul><li>操作系统只把程序的部分页面装入内存，在程序运行过程中动态的调入调出页面</li><li>请求调入和预调入<ul><li>请求调入是当执行的指令不在内存中或者数据不在内存中时，发生缺页中断，从外存中将响应的页面调入内存</li><li>预调入是系统通过对外存中的页进行调入顺序计算，估计调入顺序，按顺序进行调度</li></ul></li><li>内存中的页面被置换到外存时需要判断是否被修改</li></ul><p><strong>页面置换算法</strong></p><h2 id="malloc和mmap"><a href="#malloc和mmap" class="headerlink" title="malloc和mmap"></a>malloc和mmap</h2><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</p><p>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</p><p>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p><p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p><p>在标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p><p>malloc小于<strong>128k</strong>的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读&#x2F;写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</p><img src="/2022/10/01/mem/0.png" class=""><p>malloc大于128K的内存时，使用mmap分配，mmap将虚拟地址空间中的一块区域和文件系统(磁盘)进行一一映射，返回待映射的文件指针，当程序访问(读或写)这块内存时，会产生缺页中断，然后将内容从磁盘拷贝到物理内存中，并在页表中记录。</p><p><strong>这样访问文件系统比read()和write()要快，因为read等系统调用会先将文件拷贝到内核的缓存中，在从内核缓存拷贝到用户空间，而mmap则直接拷贝到用户空间</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lab1 mapreduce</title>
    <link href="/2022/10/01/MIT%206.824%20lab1%20mapreduce/"/>
    <url>/2022/10/01/MIT%206.824%20lab1%20mapreduce/</url>
    
    <content type="html"><![CDATA[<h2 id="golang-rpc"><a href="#golang-rpc" class="headerlink" title="golang rpc"></a>golang rpc</h2><p><a href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">Go语言高级编程</a></p><h2 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h2><p><a href="https://github.com/XcodeRole/6.824-golabs-2021">https://github.com/XcodeRole/6.824-golabs-2021</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>coordinator维护四个队列，waitformap，runmap，waitforreduce、runreduce，分别代表map task的等待队列，map task已经分配正在运行的队列，reduce task的等待队列，reduce task已经分配的正在运行的队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line"><span class="comment">// mapcounter    int</span></span><br><span class="line"><span class="comment">// reducecounter int</span></span><br><span class="line"><span class="comment">// idcounter     int</span></span><br><span class="line"><span class="comment">// 不用counter，四个队列来管理</span></span><br><span class="line">waitformap    Mapqueue</span><br><span class="line">runmap        runmapmanager</span><br><span class="line">waitforreduce Reducequeue</span><br><span class="line">runreduce     runreducemanager</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过文件名区分map task，通过reduce id区分reduce task，并且需要注意的一点是在分配reduce任务之前要等待所有的map任务完成</p><p>worker通过for循环不断向coordinator请求任务，分四种情况</p><ol><li>waitformap不为空，这时候分配map task，并把任务归到runmap中</li><li>waitformap为空，所有任务都被分配，判断runmap是否为空，若不为空，则返回worker等待，直到runmap也为空，这时侯所有map任务完成</li><li>以上两个队列都空，判断waitforreduce是否为空，不为空则分配reduce task给worker，并且把任务id归到runreduce中</li><li>当waitforreduce也为空，reduce任务也全部被分配，则判断runreduce是否为空，不为空则返回worker等待，直到runreduce为空，所有任务完成</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> Dispatch(args *DispatchArgs, reply *DispatchReply) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !c.waitformap.isEmpty() &#123;</span><br><span class="line">reply.TaskType = <span class="number">0</span>        <span class="comment">//0-map</span></span><br><span class="line">task := c.waitformap.Dequeue()</span><br><span class="line">c.runmap.syncenmap(task, <span class="number">0</span>)</span><br><span class="line">reply.Filename = <span class="type">string</span>(task)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.runmap.isEmpty() &#123; <span class="comment">//wait util all map task done</span></span><br><span class="line">reply.TaskType = <span class="number">1</span>       <span class="comment">//1-wait</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.waitforreduce.isEmpty() &#123;</span><br><span class="line">reply.TaskType = <span class="number">2</span>       <span class="comment">//2-reduce</span></span><br><span class="line">task := c.waitforreduce.Dequeue()</span><br><span class="line">c.runreduce.syncenmap(task, <span class="number">0</span>)</span><br><span class="line">reply.NoReduce = <span class="type">int</span>(task)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.runreduce.isEmpty() &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种情况是考虑到当前worker要等待其他worker执行完reduce。</span></span><br><span class="line"><span class="comment">一旦其他worker执行的reduce任务失败了，还需要重新分配reduce</span></span><br><span class="line"><span class="comment">和上面的wait map task作用一样，只不过这个是等reduce task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reply.TaskType = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reply.TaskType = <span class="number">3</span>       <span class="comment">//3-finish</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何保证一个woker earlier exit，任务没完成就退出之后的正确性？</strong></p><ol><li><p>runmap以及runreduce通过golang的map实现<code>map[task]int</code> 其中的值就是时间counter，开一个协程，每隔1s增加run(map或reduce)队列的counter，当counter超过阈值就把任务重新归入wait队列</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coordinator开一个协程来对正在运行的任务进行计时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> timemanager() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">if</span> !c.runmap.isEmpty() &#123;</span><br><span class="line">c.runmap.mu.Lock()</span><br><span class="line">c.runmap.timeplus()</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> c.runmap.runlist &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">c.waitformap.Enqueue(k)</span><br><span class="line">c.runmap.del(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.runmap.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !c.runreduce.isEmpty() &#123;</span><br><span class="line">c.runreduce.mu.Lock()</span><br><span class="line">c.runreduce.timeplus()</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> c.runreduce.runlist &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">c.waitforreduce.Enqueue(k)</span><br><span class="line">c.runreduce.del(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.runreduce.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主进程会每秒进行判断，所以这里不需要了，主进程退出，协程也会退出</span></span><br><span class="line"><span class="comment">// if c.Done() &#123;</span></span><br><span class="line"><span class="comment">// os.Exit(0)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中间文件的问题，如果一个worker产生的中间文件不处理的化，可能造成reduce任务读取出错，所以我使用mr-iHash(filename)-reduceid 的方式命名中间文件，第一个worker写了一半的文件会在下次被删掉</p></li></ol><p><strong>reduce如何区分自己的任务？</strong></p><p>读取所有以reduceid为后缀的文件，作为此次reduce task</p><p><strong>保证没有data race？</strong></p><p>每个队列结构内部都加了sync.Mutex，出队列，入队列都要加锁，计算时间的go rountine 每次也要加锁</p><h2 id="别人的实现"><a href="#别人的实现" class="headerlink" title="别人的实现"></a>别人的实现</h2><p><a href="https://www.cnblogs.com/zhujiwei/p/14572977.html">Distributed | MapReduce</a></p><p><a href="https://zhuanlan.zhihu.com/p/260752052">MIT 6.824 分布式系统 | Lab 1：MapReduce</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
