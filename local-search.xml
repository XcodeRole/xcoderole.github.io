<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>lab1 mapreduce</title>
    <link href="/2022/10/01/MIT%206.824%20lab1%20mapreduce/"/>
    <url>/2022/10/01/MIT%206.824%20lab1%20mapreduce/</url>
    
    <content type="html"><![CDATA[<h2 id="golang-rpc"><a href="#golang-rpc" class="headerlink" title="golang rpc"></a>golang rpc</h2><p><a href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">Go语言高级编程</a></p><h2 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h2><p><a href="https://github.com/XcodeRole/6.824-golabs-2021">https://github.com/XcodeRole/6.824-golabs-2021</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>coordinator维护四个队列，waitformap，runmap，waitforreduce、runreduce，分别代表map task的等待队列，map task已经分配正在运行的队列，reduce task的等待队列，reduce task已经分配的正在运行的队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line"><span class="comment">// mapcounter    int</span></span><br><span class="line"><span class="comment">// reducecounter int</span></span><br><span class="line"><span class="comment">// idcounter     int</span></span><br><span class="line"><span class="comment">// 不用counter，四个队列来管理</span></span><br><span class="line">waitformap    Mapqueue</span><br><span class="line">runmap        runmapmanager</span><br><span class="line">waitforreduce Reducequeue</span><br><span class="line">runreduce     runreducemanager</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过文件名区分map task，通过reduce id区分reduce task，并且需要注意的一点是在分配reduce任务之前要等待所有的map任务完成</p><p>worker通过for循环不断向coordinator请求任务，分四种情况</p><ol><li>waitformap不为空，这时候分配map task，并把任务归到runmap中</li><li>waitformap为空，所有任务都被分配，判断runmap是否为空，若不为空，则返回worker等待，直到runmap也为空，这时侯所有map任务完成</li><li>以上两个队列都空，判断waitforreduce是否为空，不为空则分配reduce task给worker，并且把任务id归到runreduce中</li><li>当waitforreduce也为空，reduce任务也全部被分配，则判断runreduce是否为空，不为空则返回worker等待，直到runreduce为空，所有任务完成</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> Dispatch(args *DispatchArgs, reply *DispatchReply) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !c.waitformap.isEmpty() &#123;</span><br><span class="line">reply.TaskType = <span class="number">0</span>        <span class="comment">//0-map</span></span><br><span class="line">task := c.waitformap.Dequeue()</span><br><span class="line">c.runmap.syncenmap(task, <span class="number">0</span>)</span><br><span class="line">reply.Filename = <span class="type">string</span>(task)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.runmap.isEmpty() &#123; <span class="comment">//wait util all map task done</span></span><br><span class="line">reply.TaskType = <span class="number">1</span>       <span class="comment">//1-wait</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.waitforreduce.isEmpty() &#123;</span><br><span class="line">reply.TaskType = <span class="number">2</span>       <span class="comment">//2-reduce</span></span><br><span class="line">task := c.waitforreduce.Dequeue()</span><br><span class="line">c.runreduce.syncenmap(task, <span class="number">0</span>)</span><br><span class="line">reply.NoReduce = <span class="type">int</span>(task)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !c.runreduce.isEmpty() &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种情况是考虑到当前worker要等待其他worker执行完reduce。</span></span><br><span class="line"><span class="comment">一旦其他worker执行的reduce任务失败了，还需要重新分配reduce</span></span><br><span class="line"><span class="comment">和上面的wait map task作用一样，只不过这个是等reduce task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reply.TaskType = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reply.TaskType = <span class="number">3</span>       <span class="comment">//3-finish</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何保证一个woker earlier exit，任务没完成就退出之后的正确性？</strong></p><ol><li><p>runmap以及runreduce通过golang的map实现<code>map[task]int</code> 其中的值就是时间counter，开一个协程，每隔1s增加run(map或reduce)队列的counter，当counter超过阈值就把任务重新归入wait队列</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coordinator开一个协程来对正在运行的任务进行计时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> timemanager() &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">if</span> !c.runmap.isEmpty() &#123;</span><br><span class="line">c.runmap.mu.Lock()</span><br><span class="line">c.runmap.timeplus()</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> c.runmap.runlist &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">c.waitformap.Enqueue(k)</span><br><span class="line">c.runmap.del(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.runmap.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !c.runreduce.isEmpty() &#123;</span><br><span class="line">c.runreduce.mu.Lock()</span><br><span class="line">c.runreduce.timeplus()</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> c.runreduce.runlist &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">c.waitforreduce.Enqueue(k)</span><br><span class="line">c.runreduce.del(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.runreduce.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主进程会每秒进行判断，所以这里不需要了，主进程退出，协程也会退出</span></span><br><span class="line"><span class="comment">// if c.Done() &#123;</span></span><br><span class="line"><span class="comment">// os.Exit(0)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中间文件的问题，如果一个worker产生的中间文件不处理的化，可能造成reduce任务读取出错，所以我使用mr-iHash(filename)-reduceid 的方式命名中间文件，第一个worker写了一半的文件会在下次被删掉</p></li></ol><p><strong>reduce如何区分自己的任务？</strong></p><p>读取所有以reduceid为后缀的文件，作为此次reduce task</p><p><strong>保证没有data race？</strong></p><p>每个队列结构内部都加了sync.Mutex，出队列，入队列都要加锁，计算时间的go rountine 每次也要加锁</p><h2 id="别人的实现"><a href="#别人的实现" class="headerlink" title="别人的实现"></a>别人的实现</h2><p><a href="https://www.cnblogs.com/zhujiwei/p/14572977.html">Distributed | MapReduce</a></p><p><a href="https://zhuanlan.zhihu.com/p/260752052">MIT 6.824 分布式系统 | Lab 1：MapReduce</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
